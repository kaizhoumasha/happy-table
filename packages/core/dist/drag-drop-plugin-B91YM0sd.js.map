{"version":3,"file":"drag-drop-plugin-B91YM0sd.js","names":["dragDropPlugin: GridPlugin","unsubs: Array<() => void>","dragColumnCache: { options?: any; onDragEnd?: (r: any) => void } | null","newData: RowData[]"],"sources":["../src/plugins/core/drag-drop-plugin.ts"],"sourcesContent":["import type { GridPlugin } from '../types'\nimport type { RowData } from '../../types'\nimport { createLogger } from '../../utils/logger'\n\nconst logger = createLogger('drag-drop-plugin')\n\nfunction reorderByIds(data: RowData[], sourceId: string | number, targetId: string | number): RowData[] {\n  const sourceIndex = data.findIndex(r => (r as any)?.id === sourceId)\n  const targetIndex = data.findIndex(r => (r as any)?.id === targetId)\n  if (sourceIndex === -1 || targetIndex === -1) return data\n\n  const next = data.slice()\n  const removed = next.splice(sourceIndex, 1)\n  const moved = removed[0]\n  if (!moved) return data\n  // Adjust target index if removing before insertion affects position\n  const adjustedTarget = sourceIndex < targetIndex ? targetIndex - 1 : targetIndex\n  next.splice(adjustedTarget, 0, moved)\n  return next\n}\n\nfunction reorderByIndex(data: RowData[], sourceIndex: number, destIndex: number): RowData[] {\n  if (sourceIndex === destIndex) return data\n  // Adjust destination index if we removed an element before it\n  const adjustedDestIndex = sourceIndex < destIndex ? destIndex - 1 : destIndex\n  if (adjustedDestIndex === sourceIndex) return data\n\n  const next = data.slice()\n  const [removed] = next.splice(sourceIndex, 1)\n  if (removed) {\n    next.splice(adjustedDestIndex, 0, removed)\n  }\n  return next\n}\n\nexport const dragDropPlugin: GridPlugin = {\n  name: 'drag-drop',\n  version: '1.0.0',\n  install(api, _get) {\n    const unsubs: Array<() => void> = []\n\n    // Cache drag column configuration\n    let dragColumnCache: { options?: any; onDragEnd?: (r: any) => void } | null = null\n\n    const getDragColumn = () => {\n      if (!dragColumnCache) {\n        const columns = api.getState().columns\n        const dragCol = columns.find((c: any) => c.type === 'drag') as any\n        dragColumnCache = {\n          options: dragCol?.functionalOptions,\n          onDragEnd: dragCol?.functionalOptions?.onDragEnd\n        }\n      }\n      return dragColumnCache\n    }\n\n    // Clear cache when columns change\n    const onColumnsChanged = () => {\n      dragColumnCache = null\n    }\n\n    const offColumnsChanged = api.on?.('columns-changed' as any, onColumnsChanged)\n    if (offColumnsChanged) unsubs.push(offColumnsChanged)\n\n    // Optional: observe drag start\n    const onRowDragStart = (payload: any) => {\n      logger.debug('row-drag-start', payload)\n    }\n    const offRowDragStart = api.on?.('row-drag-start' as any, onRowDragStart)\n    if (offRowDragStart) unsubs.push(offRowDragStart)\n\n    // Handle drop -> reorder using destinationIndex for accuracy\n    const onDragEnd = (payload: any) => {\n      const { result, sourceId, targetId } = payload || {}\n      if (!result) return\n\n      const raw = api.getData()\n      if (!Array.isArray(raw) || raw.length === 0) return\n\n      let newData: RowData[]\n\n      // Always use index-based reorder for accurate positioning\n      // destinationIndex is calculated based on drop position (top/bottom)\n      if (typeof result.sourceIndex === 'number' && typeof result.destinationIndex === 'number') {\n        newData = reorderByIndex(raw, result.sourceIndex, result.destinationIndex)\n      }\n      // Legacy fallback: id-based reorder (kept for backward compatibility)\n      else if (sourceId !== null && sourceId !== undefined && targetId !== null && targetId !== undefined) {\n        newData = reorderByIds(raw, sourceId, targetId)\n      } else {\n        return\n      }\n\n      if (newData !== raw) {\n        api.setData(newData)\n\n        // Invoke column-level callback if provided (only query once)\n        const dragCol = getDragColumn()\n        dragCol.onDragEnd?.(result)\n      }\n    }\n\n    const offDragEnd = api.on?.('row-drag-end' as any, onDragEnd)\n    if (offDragEnd) unsubs.push(offDragEnd)\n\n    this.cleanup = async () => {\n      dragColumnCache = null\n      unsubs.forEach(u => {\n        try {\n          u()\n        } catch (error) {\n          logger.warn('Failed to cleanup event listener:', error)\n        }\n      })\n    }\n  },\n}\n\nexport default dragDropPlugin\n"],"mappings":";AAIA,IAAM,SAAS,aAAa,mBAAmB;AAE/C,SAAS,aAAa,GAAiB,GAA2B,GAAsC;CACtG,IAAM,IAAc,EAAK,WAAU,MAAM,GAAW,OAAO,EAAS,EAC9D,IAAc,EAAK,WAAU,MAAM,GAAW,OAAO,EAAS;AACpE,KAAI,MAAgB,MAAM,MAAgB,GAAI,QAAO;CAErD,IAAM,IAAO,EAAK,OAAO,EAEnB,IADU,EAAK,OAAO,GAAa,EAAE,CACrB;AACtB,KAAI,CAAC,EAAO,QAAO;CAEnB,IAAM,IAAiB,IAAc,IAAc,IAAc,IAAI;AAErE,QADA,EAAK,OAAO,GAAgB,GAAG,EAAM,EAC9B;;AAGT,SAAS,eAAe,GAAiB,GAAqB,GAA8B;AAC1F,KAAI,MAAgB,EAAW,QAAO;CAEtC,IAAM,IAAoB,IAAc,IAAY,IAAY,IAAI;AACpE,KAAI,MAAsB,EAAa,QAAO;CAE9C,IAAM,IAAO,EAAK,OAAO,EACnB,CAAC,KAAW,EAAK,OAAO,GAAa,EAAE;AAI7C,QAHI,KACF,EAAK,OAAO,GAAmB,GAAG,EAAQ,EAErC;;AAGT,MAAaA,iBAA6B;CACxC,MAAM;CACN,SAAS;CACT,QAAQ,GAAK,GAAM;EACjB,IAAMC,IAA4B,EAAE,EAGhCC,IAA0E,MAExE,UAAsB;AAC1B,OAAI,CAAC,GAAiB;IAEpB,IAAM,IADU,EAAI,UAAU,CAAC,QACP,MAAM,MAAW,EAAE,SAAS,OAAO;AAC3D,QAAkB;KAChB,SAAS,GAAS;KAClB,WAAW,GAAS,mBAAmB;KACxC;;AAEH,UAAO;KAQH,IAAoB,EAAI,KAAK,yBAJJ;AAC7B,OAAkB;IAG0D;AAC9E,EAAI,KAAmB,EAAO,KAAK,EAAkB;EAMrD,IAAM,IAAkB,EAAI,KAAK,mBAHT,MAAiB;AACvC,UAAO,MAAM,kBAAkB,EAAQ;IAEgC;AACzE,EAAI,KAAiB,EAAO,KAAK,EAAgB;EAiCjD,IAAM,IAAa,EAAI,KAAK,iBA9BT,MAAiB;GAClC,IAAM,EAAE,WAAQ,aAAU,gBAAa,KAAW,EAAE;AACpD,OAAI,CAAC,EAAQ;GAEb,IAAM,IAAM,EAAI,SAAS;AACzB,OAAI,CAAC,MAAM,QAAQ,EAAI,IAAI,EAAI,WAAW,EAAG;GAE7C,IAAIC;AAIJ,OAAI,OAAO,EAAO,eAAgB,YAAY,OAAO,EAAO,oBAAqB,SAC/E,KAAU,eAAe,GAAK,EAAO,aAAa,EAAO,iBAAiB;YAGnE,KAAa,QAAkC,KAAa,KACnE,KAAU,aAAa,GAAK,GAAU,EAAS;OAE/C;AAGF,GAAI,MAAY,MACd,EAAI,QAAQ,EAAQ,EAGJ,GAAe,CACvB,YAAY,EAAO;IAI8B;AAG7D,EAFI,KAAY,EAAO,KAAK,EAAW,EAEvC,KAAK,UAAU,YAAY;AAEzB,GADA,IAAkB,MAClB,EAAO,SAAQ,MAAK;AAClB,QAAI;AACF,QAAG;aACI,GAAO;AACd,YAAO,KAAK,qCAAqC,EAAM;;KAEzD;;;CAGP"}