{"version":3,"file":"drag-drop-plugin-CX0SRuFH.cjs","names":["dragDropPlugin: GridPlugin","unsubs: Array<() => void>","dragColumnCache: { options?: any; onDragEnd?: (r: any) => void } | null","newData: RowData[]"],"sources":["../src/plugins/core/drag-drop-plugin.ts"],"sourcesContent":["import type { GridPlugin } from '../types'\nimport type { RowData } from '../../types'\nimport { createLogger } from '../../utils/logger'\n\nconst logger = createLogger('drag-drop-plugin')\n\nfunction reorderByIds(data: RowData[], sourceId: string | number, targetId: string | number): RowData[] {\n  const sourceIndex = data.findIndex(r => (r as any)?.id === sourceId)\n  const targetIndex = data.findIndex(r => (r as any)?.id === targetId)\n  if (sourceIndex === -1 || targetIndex === -1) return data\n\n  const next = data.slice()\n  const removed = next.splice(sourceIndex, 1)\n  const moved = removed[0]\n  if (!moved) return data\n  // Adjust target index if removing before insertion affects position\n  const adjustedTarget = sourceIndex < targetIndex ? targetIndex - 1 : targetIndex\n  next.splice(adjustedTarget, 0, moved)\n  return next\n}\n\nfunction reorderByIndex(data: RowData[], sourceIndex: number, destIndex: number): RowData[] {\n  if (sourceIndex === destIndex) return data\n  // Adjust destination index if we removed an element before it\n  const adjustedDestIndex = sourceIndex < destIndex ? destIndex - 1 : destIndex\n  if (adjustedDestIndex === sourceIndex) return data\n\n  const next = data.slice()\n  const [removed] = next.splice(sourceIndex, 1)\n  if (removed) {\n    next.splice(adjustedDestIndex, 0, removed)\n  }\n  return next\n}\n\nexport const dragDropPlugin: GridPlugin = {\n  name: 'drag-drop',\n  version: '1.0.0',\n  install(api, _get) {\n    const unsubs: Array<() => void> = []\n\n    // Cache drag column configuration\n    let dragColumnCache: { options?: any; onDragEnd?: (r: any) => void } | null = null\n\n    const getDragColumn = () => {\n      if (!dragColumnCache) {\n        const columns = api.getState().columns\n        const dragCol = columns.find((c: any) => c.type === 'drag') as any\n        dragColumnCache = {\n          options: dragCol?.functionalOptions,\n          onDragEnd: dragCol?.functionalOptions?.onDragEnd\n        }\n      }\n      return dragColumnCache\n    }\n\n    // Clear cache when columns change\n    const onColumnsChanged = () => {\n      dragColumnCache = null\n    }\n\n    const offColumnsChanged = api.on?.('columns-changed' as any, onColumnsChanged)\n    if (offColumnsChanged) unsubs.push(offColumnsChanged)\n\n    // Optional: observe drag start\n    const onRowDragStart = (payload: any) => {\n      logger.debug('row-drag-start', payload)\n    }\n    const offRowDragStart = api.on?.('row-drag-start' as any, onRowDragStart)\n    if (offRowDragStart) unsubs.push(offRowDragStart)\n\n    // Handle drop -> reorder using destinationIndex for accuracy\n    const onDragEnd = (payload: any) => {\n      const { result, sourceId, targetId } = payload || {}\n      if (!result) return\n\n      const raw = api.getData()\n      if (!Array.isArray(raw) || raw.length === 0) return\n\n      let newData: RowData[]\n\n      // Always use index-based reorder for accurate positioning\n      // destinationIndex is calculated based on drop position (top/bottom)\n      if (typeof result.sourceIndex === 'number' && typeof result.destinationIndex === 'number') {\n        newData = reorderByIndex(raw, result.sourceIndex, result.destinationIndex)\n      }\n      // Legacy fallback: id-based reorder (kept for backward compatibility)\n      else if (sourceId !== null && sourceId !== undefined && targetId !== null && targetId !== undefined) {\n        newData = reorderByIds(raw, sourceId, targetId)\n      } else {\n        return\n      }\n\n      if (newData !== raw) {\n        api.setData(newData)\n\n        // Invoke column-level callback if provided (only query once)\n        const dragCol = getDragColumn()\n        dragCol.onDragEnd?.(result)\n      }\n    }\n\n    const offDragEnd = api.on?.('row-drag-end' as any, onDragEnd)\n    if (offDragEnd) unsubs.push(offDragEnd)\n\n    this.cleanup = async () => {\n      dragColumnCache = null\n      unsubs.forEach(u => {\n        try {\n          u()\n        } catch (error) {\n          logger.warn('Failed to cleanup event listener:', error)\n        }\n      })\n    }\n  },\n}\n\nexport default dragDropPlugin\n"],"mappings":"yCAIA,IAAM,EAAS,EAAA,aAAa,mBAAmB,CAE/C,SAAS,EAAa,EAAiB,EAA2B,EAAsC,CACtG,IAAM,EAAc,EAAK,UAAU,GAAM,GAAW,KAAO,EAAS,CAC9D,EAAc,EAAK,UAAU,GAAM,GAAW,KAAO,EAAS,CACpE,GAAI,IAAgB,IAAM,IAAgB,GAAI,OAAO,EAErD,IAAM,EAAO,EAAK,OAAO,CAEnB,EADU,EAAK,OAAO,EAAa,EAAE,CACrB,GACtB,GAAI,CAAC,EAAO,OAAO,EAEnB,IAAM,EAAiB,EAAc,EAAc,EAAc,EAAI,EAErE,OADA,EAAK,OAAO,EAAgB,EAAG,EAAM,CAC9B,EAGT,SAAS,EAAe,EAAiB,EAAqB,EAA8B,CAC1F,GAAI,IAAgB,EAAW,OAAO,EAEtC,IAAM,EAAoB,EAAc,EAAY,EAAY,EAAI,EACpE,GAAI,IAAsB,EAAa,OAAO,EAE9C,IAAM,EAAO,EAAK,OAAO,CACnB,CAAC,GAAW,EAAK,OAAO,EAAa,EAAE,CAI7C,OAHI,GACF,EAAK,OAAO,EAAmB,EAAG,EAAQ,CAErC,EAGT,MAAaA,EAA6B,CACxC,KAAM,YACN,QAAS,QACT,QAAQ,EAAK,EAAM,CACjB,IAAMC,EAA4B,EAAE,CAGhCC,EAA0E,KAExE,MAAsB,CAC1B,GAAI,CAAC,EAAiB,CAEpB,IAAM,EADU,EAAI,UAAU,CAAC,QACP,KAAM,GAAW,EAAE,OAAS,OAAO,CAC3D,EAAkB,CAChB,QAAS,GAAS,kBAClB,UAAW,GAAS,mBAAmB,UACxC,CAEH,OAAO,GAQH,EAAoB,EAAI,KAAK,sBAJJ,CAC7B,EAAkB,MAG0D,CAC1E,GAAmB,EAAO,KAAK,EAAkB,CAMrD,IAAM,EAAkB,EAAI,KAAK,iBAHT,GAAiB,CACvC,EAAO,MAAM,iBAAkB,EAAQ,EAEgC,CACrE,GAAiB,EAAO,KAAK,EAAgB,CAiCjD,IAAM,EAAa,EAAI,KAAK,eA9BT,GAAiB,CAClC,GAAM,CAAE,SAAQ,WAAU,YAAa,GAAW,EAAE,CACpD,GAAI,CAAC,EAAQ,OAEb,IAAM,EAAM,EAAI,SAAS,CACzB,GAAI,CAAC,MAAM,QAAQ,EAAI,EAAI,EAAI,SAAW,EAAG,OAE7C,IAAIC,EAIJ,GAAI,OAAO,EAAO,aAAgB,UAAY,OAAO,EAAO,kBAAqB,SAC/E,EAAU,EAAe,EAAK,EAAO,YAAa,EAAO,iBAAiB,SAGnE,GAAa,MAAkC,GAAa,KACnE,EAAU,EAAa,EAAK,EAAU,EAAS,MAE/C,OAGE,IAAY,IACd,EAAI,QAAQ,EAAQ,CAGJ,GAAe,CACvB,YAAY,EAAO,GAI8B,CACzD,GAAY,EAAO,KAAK,EAAW,CAEvC,KAAK,QAAU,SAAY,CACzB,EAAkB,KAClB,EAAO,QAAQ,GAAK,CAClB,GAAI,CACF,GAAG,OACI,EAAO,CACd,EAAO,KAAK,oCAAqC,EAAM,GAEzD,GAGP"}