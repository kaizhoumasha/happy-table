{"version":3,"file":"sorting-plugin-DiKduNRw.js","names":["chunks: (string | number)[]","match: RegExpExecArray | null","comparison: number","mergedOptions: SortOptions","currentSortConfig: MultiSortConfig | null","globalSortOptions: SortOptions","sortingInterceptor: DataInterceptor | null","debouncedDataProcessing: (() => void) | null","dataPipeline: any","eventUnsubscribe: (() => void) | null","currentColumns: import('../../types').ColumnDef[]","eventUtils: ReturnType<typeof createTypedEventUtils> | null","lastSortedData: RowData[]","lastSortCacheKey: string","lastDataHash: string","timeout: number | null","newConfig: MultiSortConfig","sortingPlugin: GridPlugin","basicSortingPlugin: GridPlugin","enhancedSortingPlugin: GridPlugin"],"sources":["../src/plugins/utils/sorting-utils.ts","../src/plugins/utils/typed-event-helpers.ts","../src/plugins/core/sorting-plugin.ts"],"sourcesContent":["/**\n * Sorting Utilities Module\n *\n * Provides pure functions for sorting operations with support for:\n * - Single and multi-field sorting\n * - Custom comparators\n * - Locale-aware string comparison\n * - Null value handling\n */\n\nimport type { CellValue, RowData, SortField, SortOptions, SortConfig, MultiSortConfig } from '../../types'\n\n/**\n * Type guards for sort configurations\n */\nexport function isSingleSortConfig(config: unknown): config is SortConfig {\n  return (\n    config !== null &&\n    typeof config === 'object' &&\n    'field' in config &&\n    'direction' in config &&\n    typeof (config as Record<string, unknown>).field === 'string' &&\n    ['asc', 'desc'].includes((config as Record<string, unknown>).direction as string)\n  )\n}\n\nexport function isMultiSortConfig(config: unknown): config is MultiSortConfig {\n  return (\n    config !== null &&\n    typeof config === 'object' &&\n    'fields' in config &&\n    Array.isArray((config as Record<string, unknown>).fields)\n  )\n}\n\n/**\n * Natural sort algorithm - splits string into text and number chunks\n */\nfunction naturalSortChunks(str: string): (string | number)[] {\n  const chunks: (string | number)[] = []\n  const regex = /(\\d+)|(\\D+)/g\n  let match: RegExpExecArray | null\n\n  while ((match = regex.exec(str)) !== null) {\n    if (match[1]) {\n      // Number chunk - parse as integer\n      chunks.push(parseInt(match[1], 10))\n    } else if (match[2]) {\n      // Text chunk - keep as string\n      chunks.push(match[2])\n    }\n  }\n\n  return chunks\n}\n\n/**\n * Natural sort comparison - compares strings with embedded numbers intelligently\n * Examples: a1, a2, a10 (not a1, a10, a2)\n *\n * @param a - First string to compare\n * @param b - Second string to compare\n * @param caseSensitive - Whether comparison is case-sensitive (default: false)\n */\nfunction naturalCompare(a: string, b: string, caseSensitive = false): number {\n  const aChunks = naturalSortChunks(caseSensitive ? a : a.toLowerCase())\n  const bChunks = naturalSortChunks(caseSensitive ? b : b.toLowerCase())\n\n  const maxLength = Math.max(aChunks.length, bChunks.length)\n\n  for (let i = 0; i < maxLength; i++) {\n    const aChunk = aChunks[i]\n    const bChunk = bChunks[i]\n\n    // Handle missing chunks (one string is shorter)\n    if (aChunk === undefined) return -1\n    if (bChunk === undefined) return 1\n\n    // Both are numbers - numerical comparison\n    if (typeof aChunk === 'number' && typeof bChunk === 'number') {\n      if (aChunk !== bChunk) {\n        return aChunk - bChunk\n      }\n      continue\n    }\n\n    // Both are strings - lexical comparison\n    if (typeof aChunk === 'string' && typeof bChunk === 'string') {\n      const comparison = aChunk.localeCompare(bChunk)\n      if (comparison !== 0) {\n        return comparison\n      }\n      continue\n    }\n\n    // Mixed types - numbers come before strings\n    if (typeof aChunk === 'number') return -1\n    if (typeof bChunk === 'number') return 1\n  }\n\n  return 0\n}\n\n/**\n * Core sorting utilities\n */\nexport class SortingUtils {\n  /**\n   * Compare two cell values with optional locale and formatting options\n   */\n  static compareValues(a: CellValue, b: CellValue, options?: SortOptions): number {\n    // Handle null/undefined values\n    if (a === null && b === null) return 0\n    if (a === null || a === undefined) return -1\n    if (b === null || b === undefined) return 1\n\n    // Handle different data types\n    if (typeof a === 'number' && typeof b === 'number') {\n      return a - b\n    }\n\n    if (a instanceof Date && b instanceof Date) {\n      return a.getTime() - b.getTime()\n    }\n\n    // String comparison with options\n    const aStr = String(a)\n    const bStr = String(b)\n\n    // Natural sort if enabled (priority over other options)\n    if (options?.naturalSort) {\n      // Prefer Intl.Collator with numeric for robust natural sorting\n      try {\n        const collator = new Intl.Collator(options.locale, {\n          numeric: true,\n          sensitivity: options.sensitivity || 'base',\n        })\n        return collator.compare(aStr, bStr)\n      } catch {\n        // Fallback: Use sensitivity to determine case handling\n        const caseSensitive = options.sensitivity === 'variant' || options.sensitivity === 'case'\n        return naturalCompare(aStr, bStr, caseSensitive)\n      }\n    }\n\n    // Locale-aware comparison with options\n    if (options?.locale || options?.sensitivity) {\n      return aStr.localeCompare(bStr, options.locale, {\n        sensitivity: options.sensitivity,\n      })\n    }\n\n    return aStr.localeCompare(bStr)\n  }\n\n  /**\n   * Apply sorting for a single field\n   */\n  static applySortField(data: RowData[], sortField: SortField, globalOptions?: SortOptions): RowData[] {\n    if (!data.length) return data\n\n    const { field, direction, nullsFirst, customComparator } = sortField\n\n    return [...data].sort((a, b) => {\n      const aVal = a[field] as CellValue\n      const bVal = b[field] as CellValue\n\n      // Handle nulls placement\n      if (nullsFirst !== undefined) {\n        if ((aVal === null || aVal === undefined) && (bVal === null || bVal === undefined)) return 0\n        if (aVal === null || aVal === undefined) return nullsFirst ? -1 : 1\n        if (bVal === null || bVal === undefined) return nullsFirst ? 1 : -1\n      }\n\n      // Use custom comparator if provided\n      let comparison: number\n      try {\n        comparison = customComparator\n          ? customComparator(aVal, bVal)\n          : this.compareValues(aVal, bVal, globalOptions)\n      } catch (_error) {\n        // Fallback to basic comparison if custom comparator fails\n        comparison = this.compareValues(aVal, bVal, globalOptions)\n      }\n\n      return direction === 'desc' ? -comparison : comparison\n    })\n  }\n\n  /**\n   * Apply multi-field sorting with priority handling\n   * Supports per-field options (SortField extends SortOptions)\n   */\n  static applyMultiSort(data: RowData[], sortFields: SortField[], globalOptions?: SortOptions): RowData[] {\n    if (!data.length || sortFields.length === 0) return data\n\n    // Validate and normalize priorities\n    const validFields = this.validateSortFields(sortFields)\n    if (validFields.length === 0) return data\n\n    // Sort by priority (0 = highest priority)\n    const sortedFields = [...validFields].sort((a, b) => a.priority - b.priority)\n\n    return [...data].sort((a, b) => {\n      for (const sortField of sortedFields) {\n        const { field, direction, nullsFirst, customComparator } = sortField\n        const aVal = a[field] as CellValue\n        const bVal = b[field] as CellValue\n\n        // Merge options: field-level > global-level\n        // SortField extends SortOptions, so sortField contains all comparison options\n        // Extract only SortOptions properties, not field/direction/priority\n        const mergedOptions: SortOptions = {\n          ...globalOptions,\n          // Only merge SortOptions properties from sortField\n          ...(sortField.naturalSort !== undefined && { naturalSort: sortField.naturalSort }),\n          ...(sortField.sensitivity !== undefined && { sensitivity: sortField.sensitivity }),\n          ...(sortField.locale !== undefined && { locale: sortField.locale }),\n        }\n\n        // Handle nulls placement\n        if (nullsFirst !== undefined) {\n          if ((aVal === null || aVal === undefined) && (bVal === null || bVal === undefined)) continue\n          if (aVal === null || aVal === undefined) return nullsFirst ? -1 : 1\n          if (bVal === null || bVal === undefined) return nullsFirst ? 1 : -1\n        }\n\n        // Compare values\n        let comparison: number\n        try {\n          comparison = customComparator\n            ? customComparator(aVal, bVal)\n            : this.compareValues(aVal, bVal, mergedOptions)\n        } catch (_error) {\n          // Fallback to basic comparison if custom comparator fails\n          comparison = this.compareValues(aVal, bVal, mergedOptions)\n        }\n\n        if (comparison !== 0) {\n          return direction === 'desc' ? -comparison : comparison\n        }\n        // If values are equal, continue to next sort field\n      }\n      return 0 // All sort fields are equal\n    })\n  }\n\n  /**\n   * Normalize sort configuration to multi-sort format\n   */\n  static normalizeToMultiSort(config: SortConfig | MultiSortConfig | null): MultiSortConfig | null {\n    if (!config) return null\n\n    if (isSingleSortConfig(config)) {\n      return {\n        fields: [\n          {\n            field: config.field,\n            direction: config.direction,\n            priority: 0,\n          },\n        ],\n      }\n    }\n\n    if (isMultiSortConfig(config)) {\n      return {\n        ...config,\n        fields: this.validateSortFields(config.fields)\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Validate and normalize sort field priorities\n   */\n  static validateSortFields(fields: SortField[]): SortField[] {\n    if (!Array.isArray(fields)) return []\n\n    return fields\n      .filter(field =>\n        field &&\n        typeof field === 'object' &&\n        typeof field.field === 'string' &&\n        field.field.trim() !== '' &&\n        ['asc', 'desc'].includes(field.direction)\n      )\n      .map((field, index) => ({\n        ...field,\n        priority: typeof field.priority === 'number' ? field.priority : index,\n      }))\n      .sort((a, b) => a.priority - b.priority)\n  }\n\n  /**\n   * Normalize sort priorities ensuring sequential numbering\n   */\n  static normalizeSortPriorities(fields: SortField[]): SortField[] {\n    const validFields = this.validateSortFields(fields)\n    return validFields.map((field, index) => ({ ...field, priority: index }))\n  }\n\n  /**\n   * Check if two sort configurations are equivalent\n   */\n  static areSortConfigsEqual(\n    config1: SortConfig | MultiSortConfig | null,\n    config2: SortConfig | MultiSortConfig | null\n  ): boolean {\n    if (config1 === config2) return true\n    if (!config1 || !config2) return false\n\n    const normalized1 = this.normalizeToMultiSort(config1)\n    const normalized2 = this.normalizeToMultiSort(config2)\n\n    if (!normalized1 || !normalized2) return false\n    if (normalized1.fields.length !== normalized2.fields.length) return false\n\n    return normalized1.fields.every((field1, index) => {\n      const field2 = normalized2.fields[index]\n      return field2 &&\n        field1.field === field2.field &&\n        field1.direction === field2.direction &&\n        field1.priority === field2.priority &&\n        field1.nullsFirst === field2.nullsFirst\n    })\n  }\n}\n","/**\n * Typed Event Helpers for Plugin System\n * \n * Provides type-safe event emission and handling utilities for plugins.\n * Eliminates the need for 'as any' assertions by creating properly typed\n * event emission patterns with backward compatibility.\n */\n\nimport type { GridAPI, GridEvents } from '../../types'\n\n/**\n * Type-safe event emitter helper for plugins\n * Ensures event names and payloads match the GridEvents interface\n */\nexport class TypedEventEmitter {\n  private api: GridAPI\n\n  constructor(api: GridAPI) {\n    this.api = api\n  }\n\n  /**\n   * Emit a typed event with full type safety\n   */\n  emit<K extends keyof GridEvents>(event: K, payload: GridEvents[K]): void {\n    if (this.api.emit) {\n      this.api.emit(event, payload)\n    }\n  }\n\n  /**\n   * Register a typed event listener with full type safety\n   */\n  on<K extends keyof GridEvents>(\n    event: K, \n    handler: (payload: GridEvents[K]) => void\n  ): (() => void) | undefined {\n    if (this.api.on) {\n      return this.api.on(event, handler)\n    }\n    return undefined\n  }\n\n  /**\n   * Remove a typed event listener\n   */\n  off<K extends keyof GridEvents>(\n    event: K, \n    handler: (payload: GridEvents[K]) => void\n  ): void {\n    if (this.api.off) {\n      this.api.off(event, handler)\n    }\n  }\n}\n\n/**\n * Plugin event emission utilities - provides convenient methods for common plugin events\n */\nexport class PluginEventUtils {\n  private emitter: TypedEventEmitter\n\n  constructor(api: GridAPI) {\n    this.emitter = new TypedEventEmitter(api)\n  }\n\n  // Sorting-related events\n  emitMultiSortChange(config: GridEvents['multi-sort-change']): void {\n    this.emitter.emit('multi-sort-change', config)\n  }\n\n  emitSortFieldAdded(data: GridEvents['sort-field-added']): void {\n    this.emitter.emit('sort-field-added', data)\n  }\n\n  emitSortFieldRemoved(data: GridEvents['sort-field-removed']): void {\n    this.emitter.emit('sort-field-removed', data)\n  }\n\n  emitSortPriorityChanged(data: GridEvents['sort-priority-changed']): void {\n    this.emitter.emit('sort-priority-changed', data)\n  }\n\n  // Selection-related events\n  emitSelectionModeChange(mode: GridEvents['selection-mode-change']): void {\n    this.emitter.emit('selection-mode-change', mode)\n  }\n\n  emitRangeSelect(data: GridEvents['range-select']): void {\n    this.emitter.emit('range-select', data)\n  }\n\n  emitSelectAll(data: GridEvents['select-all']): void {\n    this.emitter.emit('select-all', data)\n  }\n\n  emitSelectionClear(data: GridEvents['selection-clear']): void {\n    this.emitter.emit('selection-clear', data)\n  }\n\n  // Data pipeline events\n  emitDataProcessed(data: GridEvents['data-processed']): void {\n    this.emitter.emit('data-processed', data)\n  }\n\n  emitDataPipelineComplete(data: GridEvents['data-pipeline-complete']): void {\n    this.emitter.emit('data-pipeline-complete', data)\n  }\n\n  emitDataPipelineError(error: GridEvents['data-pipeline-error']): void {\n    this.emitter.emit('data-pipeline-error', error)\n  }\n\n  // Cell editing events\n  emitCellFocusChange(data: GridEvents['cell-focus-change']): void {\n    this.emitter.emit('cell-focus-change', data)\n  }\n\n  emitCellEditStart(data: GridEvents['cell-edit-start']): void {\n    this.emitter.emit('cell-edit-start', data)\n  }\n\n  emitCellEditComplete(data: GridEvents['cell-edit-complete']): void {\n    this.emitter.emit('cell-edit-complete', data)\n  }\n\n  emitCellEditCancel(data: GridEvents['cell-edit-cancel']): void {\n    this.emitter.emit('cell-edit-cancel', data)\n  }\n\n  // Plugin lifecycle events\n  emitPluginLoaded(data: GridEvents['plugin-loaded']): void {\n    this.emitter.emit('plugin-loaded', data)\n  }\n\n  emitPluginUnloaded(data: GridEvents['plugin-unloaded']): void {\n    this.emitter.emit('plugin-unloaded', data)\n  }\n\n  emitPluginError(data: GridEvents['plugin-error']): void {\n    this.emitter.emit('plugin-error', data)\n  }\n\n  // Generic event emission with dynamic typing\n  emit<K extends keyof GridEvents>(event: K, payload: GridEvents[K]): void {\n    this.emitter.emit(event, payload)\n  }\n\n  // Event listener registration\n  on<K extends keyof GridEvents>(\n    event: K, \n    handler: (payload: GridEvents[K]) => void\n  ): (() => void) | undefined {\n    return this.emitter.on(event, handler)\n  }\n\n  // Event listener removal\n  off<K extends keyof GridEvents>(\n    event: K, \n    handler: (payload: GridEvents[K]) => void\n  ): void {\n    this.emitter.off(event, handler)\n  }\n}\n\n/**\n * Factory function to create typed event utilities for plugins\n */\nexport function createTypedEventUtils(api: GridAPI): PluginEventUtils {\n  return new PluginEventUtils(api)\n}\n\n/**\n * Type guard to check if API has event emission capabilities\n */\nexport function hasEventCapabilities(api: GridAPI): api is GridAPI & Required<Pick<GridAPI, 'emit' | 'on' | 'off'>> {\n  return typeof api.emit === 'function'\n}\n\n/**\n * Generic type-safe event emission helper\n * Use this when you need maximum type safety with minimal overhead\n */\nexport function safeEmit<K extends keyof GridEvents>(\n  api: GridAPI, \n  event: K, \n  payload: GridEvents[K]\n): void {\n  if (hasEventCapabilities(api)) {\n    api.emit(event, payload)\n  }\n}\n\n/**\n * Generic type-safe event listener registration helper\n */\nexport function safeOn<K extends keyof GridEvents>(\n  api: GridAPI,\n  event: K,\n  handler: (payload: GridEvents[K]) => void\n): (() => void) | undefined {\n  if (api.on) {\n    return api.on(event, handler)\n  }\n  return undefined\n}\n\n/**\n * Extension helper types for plugins that need to add custom events\n * This allows plugins to extend the GridEvents interface safely\n */\nexport type ExtendedEventMap<T extends Record<string, unknown>> = GridEvents & T\n\n/**\n * Helper to create type-safe custom event emitters for plugins with extended events\n */\nexport function createExtendedEventUtils<T extends Record<string, unknown>>(\n  api: GridAPI\n): {\n  emit<K extends keyof ExtendedEventMap<T>>(event: K, payload: ExtendedEventMap<T>[K]): void\n  on<K extends keyof ExtendedEventMap<T>>(event: K, handler: (payload: ExtendedEventMap<T>[K]) => void): (() => void) | undefined\n  off<K extends keyof ExtendedEventMap<T>>(event: K, handler: (payload: ExtendedEventMap<T>[K]) => void): void\n} {\n  return {\n    emit<K extends keyof ExtendedEventMap<T>>(event: K, payload: ExtendedEventMap<T>[K]): void {\n      if (api.emit) {\n        // Type assertion is safe here because we're extending the base event map\n        api.emit(event as keyof GridEvents, payload as GridEvents[keyof GridEvents])\n      }\n    },\n    on<K extends keyof ExtendedEventMap<T>>(\n      event: K, \n      handler: (payload: ExtendedEventMap<T>[K]) => void\n    ): (() => void) | undefined {\n      if (api.on) {\n        return api.on(event as keyof GridEvents, handler as (payload: GridEvents[keyof GridEvents]) => void)\n      }\n      return undefined\n    },\n    off<K extends keyof ExtendedEventMap<T>>(\n      event: K, \n      handler: (payload: ExtendedEventMap<T>[K]) => void\n    ): void {\n      if (api.off) {\n        api.off(event as keyof GridEvents, handler as (payload: GridEvents[keyof GridEvents]) => void)\n      }\n    }\n  }\n}\n","/**\n * Simplified Sorting Plugin - Streamlined sorting capabilities\n *\n * Refactored architecture following SOLID and KISS principles:\n * - Single factory function with minimal essential configuration\n * - Direct plugin implementation without unnecessary abstraction layers\n * - Focused, minimal surface without legacy shims\n *\n * @version 2.1.0\n */\n\nimport type { GridPlugin, CapabilityGetter } from '../types'\nimport type { GridAPI, SortConfig, MultiSortConfig, SortOptions, RowData } from '../../types'\nimport type { DataInterceptor } from '../capabilities/data-pipeline-capability'\nimport { createLogger } from '../../utils/logger'\nimport { SortingUtils } from '../utils/sorting-utils'\nimport { createTypedEventUtils, hasEventCapabilities } from '../utils/typed-event-helpers'\n\n// Simplified configuration interface - only essential options\nexport interface SortingPluginOptions {\n  /** Enable multi-field sorting capability (default: true) */\n  enableMultiSort?: boolean\n  /** Maximum number of sort fields (default: 5) */\n  maxSortFields?: number\n}\n\n/**\n * Helper function to extract SortOptions from column definition\n */\nfunction getColumnSortOptions(columnDef: import('../../types').ColumnDef | undefined): SortOptions | null {\n  if (!columnDef || !columnDef.sortable) {\n    return null\n  }\n\n  // If sortable is boolean true, return empty options (use defaults)\n  if (columnDef.sortable === true) {\n    return {}\n  }\n\n  // If sortable is SortOptions object, return it\n  if (typeof columnDef.sortable === 'object') {\n    return columnDef.sortable\n  }\n\n  return null\n}\n\n/**\n * Merge global sort options with column-specific options\n * Column options take precedence over global options\n */\nfunction mergeSortOptions(globalOptions: SortOptions, columnOptions: SortOptions | null): SortOptions {\n  if (!columnOptions) {\n    return globalOptions\n  }\n\n  return {\n    ...globalOptions,\n    ...columnOptions,\n  }\n}\n\n/**\n * Create a sorting plugin with specified configuration\n */\nexport function createSortingPlugin(options: SortingPluginOptions = {}): GridPlugin {\n  // Initialize logger first\n  const logger = createLogger({ module: 'Plugin', operation: 'SortingPlugin' })\n\n  // Normalize options with sensible defaults\n  const config = {\n    enableMultiSort: options.enableMultiSort ?? true,\n    maxSortFields: Math.max(1, Math.min(options.maxSortFields ?? 5, 10)),\n  }\n\n  logger.debug('Creating sorting plugin', { config, options })\n\n  // Plugin state\n  let currentSortConfig: MultiSortConfig | null = null\n  let globalSortOptions: SortOptions = {}\n  let sortingInterceptor: DataInterceptor | null = null\n  let debouncedDataProcessing: (() => void) | null = null\n  let dataPipeline: any = null\n  let eventUnsubscribe: (() => void) | null = null\n  let currentColumns: import('../../types').ColumnDef[] = []\n\n  // Typed event utilities for safe event emission\n  let eventUtils: ReturnType<typeof createTypedEventUtils> | null = null\n\n  // Caching mechanism for performance optimization\n  let lastSortedData: RowData[] = []\n  let lastSortCacheKey: string = '' // Composite key: sortConfig + options\n  let lastDataHash: string = ''\n\n  // Debounce utility for performance optimization\n  const createDebounced = <T extends (...args: unknown[]) => void>(func: T, wait: number): T => {\n    let timeout: number | null = null\n    return ((...args: Parameters<T>) => {\n      if (timeout) clearTimeout(timeout)\n      timeout = setTimeout(() => func(...args), wait) as number\n    }) as T\n  }\n\n  // Type guard for API methods\n  const hasMethod = <T extends keyof GridAPI>(api: GridAPI, method: T): api is GridAPI & Required<Pick<GridAPI, T>> => {\n    return typeof api[method] === 'function'\n  }\n\n  // Core sorting logic\n  const setSortConfig = (api: GridAPI, sortConfig: SortConfig | MultiSortConfig | null): void => {\n    const normalizedConfig = SortingUtils.normalizeToMultiSort(sortConfig)\n\n    logger.debug('setSortConfig called', {\n      originalConfig: sortConfig,\n      normalizedConfig,\n      currentSortConfig,\n      enableMultiSort: config.enableMultiSort\n    })\n\n    // Validate multi-sort constraints\n    if (!config.enableMultiSort && normalizedConfig?.fields && normalizedConfig.fields.length > 1) {\n      logger.warn('Multi-sort disabled, using only first sort field')\n      normalizedConfig.fields = normalizedConfig.fields.slice(0, 1)\n    }\n\n    // Only update if configuration actually changed\n    if (!SortingUtils.areSortConfigsEqual(currentSortConfig, normalizedConfig)) {\n      logger.info('Sort config changed, updating state and triggering data processing')\n      currentSortConfig = normalizedConfig\n\n      // Clear cache when sort config changes\n      lastSortedData = []\n      lastSortCacheKey = ''\n      lastDataHash = ''\n\n      // Update interceptor state\n      if (sortingInterceptor) {\n        sortingInterceptor.enabled = normalizedConfig !== null\n      }\n\n      // Safe API updates using defensive programming\n      try {\n        if (hasMethod(api, 'updateConfig')) {\n          api.updateConfig({ sort: sortConfig })\n        }\n        if (eventUtils && hasEventCapabilities(api)) {\n          // Emit multi-sort-change with complete state only\n          if (normalizedConfig) {\n            eventUtils.emitMultiSortChange(normalizedConfig)\n            logger.debug('Emitted multi-sort-change event', { config: normalizedConfig })\n          }\n        }\n      } catch (error) {\n        logger.warn('Failed to update API state:', error)\n      }\n\n      // Trigger data processing (debounced to avoid multiple calls)\n      if (debouncedDataProcessing) {\n        debouncedDataProcessing()\n      }\n    }\n  }\n\n  const getSortConfig = (): SortConfig | MultiSortConfig | null => {\n    // Prefer returning multi-sort config for consistency\n    if (currentSortConfig) return currentSortConfig\n    return null\n  }\n\n  const sortByColumn = (api: GridAPI, field: string, direction?: 'asc' | 'desc'): void => {\n    if (!field || typeof field !== 'string') {\n      logger.warn('Invalid field provided to sortByColumn')\n      return\n    }\n\n    if (!direction) {\n      const existingField = currentSortConfig?.fields.find(f => f.field === field)\n\n      // Three-state cycle: none -> asc -> desc -> none\n      if (!existingField) {\n        direction = 'asc' // First click: sort ascending\n      } else if (existingField.direction === 'asc') {\n        direction = 'desc' // Second click: sort descending\n      } else {\n        // Third click: clear sort for this field\n        logger.debug('Clearing sort for field', { field })\n\n        // If this is the only sorted field, clear all sorting\n        if (currentSortConfig && currentSortConfig.fields.length === 1) {\n          setSortConfig(api, null)\n        } else {\n          // Remove only this field from multi-sort\n          removeSortField(api, field)\n        }\n        return\n      }\n    }\n\n    const newConfig: MultiSortConfig = {\n      fields: [{ field, direction, priority: 0 }],\n    }\n\n    setSortConfig(api, newConfig)\n  }\n\n  const addSortField = (api: GridAPI, field: string, direction?: 'asc' | 'desc'): void => {\n    if (!field || typeof field !== 'string') {\n      logger.warn('Invalid field provided to addSortField')\n      return\n    }\n\n    // Create a copy of current fields to avoid mutating state\n    const currentFields = [...(currentSortConfig?.fields || [])]\n    const maxFields = config.maxSortFields\n\n    logger.debug('addSortField called', { field, direction, currentFields, maxFields })\n\n    // Check for existing field\n    const existingIndex = currentFields.findIndex(f => f.field === field)\n    if (existingIndex !== -1) {\n      const currentDirection = currentFields[existingIndex]!.direction\n\n      if (!direction) {\n        // Three-state cycle: asc → desc → clear (consistent with sortByColumn)\n        if (currentDirection === 'asc') {\n          // Second click: toggle to desc\n          currentFields[existingIndex] = { ...currentFields[existingIndex]!, direction: 'desc' }\n          logger.debug('Updated existing field to desc', { index: existingIndex, from: currentDirection })\n        } else {\n          // Third click: remove field from multi-sort\n          currentFields.splice(existingIndex, 1)\n          logger.debug('Removed field from multi-sort', { field, remainingFields: currentFields.length })\n\n          // Clear all sorting if no fields remain\n          if (currentFields.length === 0) {\n            setSortConfig(api, null)\n            if (eventUtils) {\n              eventUtils.emitSortFieldRemoved({ field, sortConfig: { fields: [] } })\n            }\n            return\n          }\n\n          // Update config with remaining fields\n          const newConfig: MultiSortConfig = {\n            fields: SortingUtils.normalizeSortPriorities(currentFields),\n          }\n          setSortConfig(api, newConfig)\n          if (eventUtils) {\n            eventUtils.emitSortFieldRemoved({ field, sortConfig: newConfig })\n          }\n          return\n        }\n      } else {\n        // Explicit direction provided: set it directly\n        currentFields[existingIndex] = { ...currentFields[existingIndex]!, direction }\n        logger.debug('Updated existing field with explicit direction', { index: existingIndex, direction })\n      }\n    } else if (currentFields.length < maxFields) {\n      // Add new field with specified direction or default to 'asc'\n      const newDirection = direction || 'asc'\n      currentFields.push({ field, direction: newDirection, priority: currentFields.length })\n      logger.debug('Added new field', { totalFields: currentFields.length, direction: newDirection })\n    } else {\n      logger.warn(`Maximum sort fields (${maxFields}) reached`)\n      return\n    }\n\n    const newConfig: MultiSortConfig = {\n      fields: SortingUtils.normalizeSortPriorities(currentFields),\n    }\n\n    logger.debug('addSortField: About to call setSortConfig', { newConfig })\n    setSortConfig(api, newConfig)\n\n    // Emit field-specific event\n    if (eventUtils) {\n      eventUtils.emitSortFieldAdded({ field: { field, direction: direction || 'asc', priority: 0 }, sortConfig: newConfig })\n    }\n  }\n\n  const removeSortField = (api: GridAPI, field: string): void => {\n    if (!currentSortConfig || !field) return\n\n    const filteredFields = currentSortConfig.fields.filter(f => f.field !== field)\n\n    if (filteredFields.length === 0) {\n      setSortConfig(api, null)\n    } else {\n      const newConfig: MultiSortConfig = {\n        fields: SortingUtils.normalizeSortPriorities(filteredFields),\n      }\n      setSortConfig(api, newConfig)\n\n      if (eventUtils) {\n        eventUtils.emitSortFieldRemoved({ field, sortConfig: newConfig })\n      }\n    }\n  }\n\n  const changeSortPriority = (api: GridAPI, field: string, newPriority: number): void => {\n    if (!currentSortConfig || !field || typeof newPriority !== 'number') return\n\n    const fields = [...currentSortConfig.fields]\n    const fieldIndex = fields.findIndex(f => f.field === field)\n\n    if (fieldIndex === -1) return\n\n    // Clamp priority to valid range\n    const maxPriority = fields.length - 1\n    const clampedPriority = Math.max(0, Math.min(newPriority, maxPriority))\n\n    // Update field priority\n    fields[fieldIndex] = { ...fields[fieldIndex]!, priority: clampedPriority }\n\n    const newConfig: MultiSortConfig = {\n      fields: SortingUtils.normalizeSortPriorities(fields),\n    }\n    setSortConfig(api, newConfig)\n\n    if (eventUtils) {\n      eventUtils.emitSortPriorityChanged({\n        field,\n        oldPriority: currentSortConfig.fields[fieldIndex]?.priority || 0,\n        newPriority: clampedPriority\n      })\n    }\n  }\n\n\n  // Plugin interface implementation\n  return {\n    name: 'sorting',\n    version: '2.1.0',\n    dependencies: ['data-pipeline'],\n\n    install(api: GridAPI, get: CapabilityGetter): void {\n      dataPipeline = get('data-pipeline')\n\n      if (!dataPipeline) {\n        logger.warn('data-pipeline capability not available')\n        return\n      }\n\n      // Create typed event utilities\n      eventUtils = createTypedEventUtils(api)\n\n      // Create debounced processing - trigger main data pipeline instead of direct processing\n      debouncedDataProcessing = createDebounced(() => {\n        // Emit event to trigger main data pipeline refresh\n        if (eventUtils) {\n          eventUtils.emit('data-refresh-requested', { source: 'sorting' })\n        }\n      }, 16)\n\n      // Create sorting interceptor\n      sortingInterceptor = {\n        name: 'sorting',\n        type: 'sort',\n        priority: 100,\n        enabled: true,\n        transform: (data: RowData[]) => {\n          // Generate hashes for caching\n          const dataHash = JSON.stringify(data.length > 0 ? [data[0], data.length] : [])\n          const sortConfigHash = JSON.stringify(currentSortConfig)\n\n          logger.debug('Sorting interceptor transform called', {\n            dataLength: data.length,\n            currentSortConfig,\n            fieldsCount: currentSortConfig?.fields?.length || 0,\n          })\n\n          if (!currentSortConfig || !data.length || currentSortConfig.fields.length === 0) {\n            logger.debug('No sorting config or empty data, returning original data')\n            return data\n          }\n\n          try {\n            // Merge column-level options into each sort field\n            // Priority: field-level > column-level > global-level\n            const fieldsWithMergedOptions = currentSortConfig.fields.map(field => {\n              const column = currentColumns.find(col => col.field === field.field)\n              const columnSortOptions = getColumnSortOptions(column)\n              const mergedColumnAndGlobal = mergeSortOptions(globalSortOptions, columnSortOptions)\n\n              // Build complete field with merged options\n              // Keep field/direction/priority from the field, merge in sort options\n              return {\n                field: field.field,\n                direction: field.direction,\n                priority: field.priority,\n                ...mergedColumnAndGlobal,  // Column + global sort options\n                // Field-level sort options override (if present)\n                ...(field.naturalSort !== undefined && { naturalSort: field.naturalSort }),\n                ...(field.sensitivity !== undefined && { sensitivity: field.sensitivity }),\n                ...(field.locale !== undefined && { locale: field.locale }),\n                ...(field.nullsFirst !== undefined && { nullsFirst: field.nullsFirst }),\n                ...(field.customComparator !== undefined && { customComparator: field.customComparator }),\n              }\n            })\n\n            // Build options hash for cache validation\n            const optionsHash = JSON.stringify(\n              fieldsWithMergedOptions.map(f => ({\n                field: f.field,\n                direction: f.direction,\n                priority: f.priority,\n                naturalSort: (f as SortOptions).naturalSort ?? false,\n                sensitivity: (f as SortOptions).sensitivity ?? undefined,\n                locale: (f as SortOptions).locale ?? undefined,\n                nullsFirst: (f as SortOptions).nullsFirst ?? undefined,\n              }))\n            )\n\n            // Build composite cache key from config + options\n            const sortCacheKey = `${sortConfigHash}|${optionsHash}`\n\n            // Check cache with options awareness\n            if (\n              dataHash === lastDataHash &&\n              sortCacheKey === lastSortCacheKey &&\n              lastSortedData.length > 0\n            ) {\n              logger.debug('Sorting interceptor: Using cached result (no changes detected)')\n              return lastSortedData\n            }\n\n            // Apply multi-sort with merged options\n            // applyMultiSort will further merge field options with any remaining global options\n            const sortedData = SortingUtils.applyMultiSort(data, fieldsWithMergedOptions, globalSortOptions)\n\n            // Update cache\n            lastSortedData = sortedData\n            lastDataHash = dataHash\n            lastSortCacheKey = sortCacheKey\n\n            logger.debug('Data sorted successfully', {\n              originalLength: data.length,\n              sortedLength: sortedData.length,\n              sortFields: fieldsWithMergedOptions\n            })\n            return sortedData\n          } catch (error) {\n            logger.error('Error during sorting:', error)\n            return data\n          }\n        },\n        metadata: {\n          description: config.enableMultiSort ? 'Multi-field sorting' : 'Single-field sorting',\n          version: '2.1.0',\n          supportedFeatures: ['single-field', ...(config.enableMultiSort ? ['multi-field'] : [])],\n        },\n      }\n\n      // Register interceptor\n      dataPipeline.registerDataInterceptor('sort', sortingInterceptor)\n\n      // Extend GridAPI safely\n      const extendedApi = api as GridAPI & Record<string, unknown>\n\n      // Core sorting methods\n      extendedApi.setSortConfig = (sortConfig: SortConfig | MultiSortConfig | null) => setSortConfig(api, sortConfig)\n      extendedApi.getSortConfig = () => getSortConfig()\n      extendedApi.sortByColumn = (field: string, direction?: 'asc' | 'desc') => sortByColumn(api, field, direction)\n      extendedApi.clearSort = () => setSortConfig(api, null)\n\n      // Multi-field methods (conditional)\n      if (config.enableMultiSort) {\n        logger.debug('Installing multi-sort methods', { config })\n        extendedApi.getMultiSortConfig = () => currentSortConfig\n        extendedApi.addSortField = (field: string, direction?: 'asc' | 'desc') => {\n          logger.debug('addSortField API called', { field, direction })\n          return addSortField(api, field, direction)\n        }\n        extendedApi.removeSortField = (field: string) => removeSortField(api, field)\n        extendedApi.changeSortPriority = (field: string, newPriority: number) => changeSortPriority(api, field, newPriority)\n      } else {\n        logger.debug('Multi-sort disabled', { config })\n      }\n\n      // Advanced options\n      extendedApi.setSortOptions = (options: SortOptions) => {\n        if (options && typeof options === 'object') {\n          globalSortOptions = { ...globalSortOptions, ...options }\n          if (currentSortConfig && debouncedDataProcessing) {\n            debouncedDataProcessing()\n          }\n        }\n      }\n      extendedApi.getSortOptions = () => globalSortOptions\n\n      // State management\n      extendedApi.exportSortState = () => ({\n        sortConfig: currentSortConfig,\n        globalOptions: globalSortOptions,\n        version: '2.1.0',\n      })\n\n      extendedApi.importSortState = (state: Record<string, unknown>) => {\n        if (state?.sortConfig) {\n          setSortConfig(api, state.sortConfig as SortConfig | MultiSortConfig)\n        }\n        if (state?.globalOptions) {\n          globalSortOptions = state.globalOptions as SortOptions\n        }\n      }\n\n      // Cleanup function\n      extendedApi._sortingPluginCleanup = () => {\n        if (dataPipeline && sortingInterceptor) {\n          dataPipeline.removeDataInterceptor('sort', 'sorting')\n        }\n        if (eventUnsubscribe) {\n          eventUnsubscribe()\n        }\n        currentSortConfig = null\n        globalSortOptions = {}\n        debouncedDataProcessing = null\n        sortingInterceptor = null\n      }\n\n      // Event handling\n      if (eventUtils && api.on) {\n        // Listen for column changes to update column-specific sort options\n        const unsubscribeColumns = api.on('columns-changed', (columns: import('../../types').ColumnDef[]) => {\n          currentColumns = columns\n          logger.debug('Columns updated', { columnCount: columns.length })\n\n          // Clear cache when columns change as sort options might have changed\n          lastSortedData = []\n          lastDataHash = ''\n          lastSortCacheKey = ''\n\n          // Trigger re-sort if there's an active sort config\n          if (currentSortConfig && debouncedDataProcessing) {\n            debouncedDataProcessing()\n          }\n        })\n\n        // Listen for config changes to update global sort options\n        const unsubscribeConfig = api.on('config-changed', (newConfig: import('../../types').GridConfig) => {\n          if (newConfig.sortOptions) {\n            logger.debug('Config changed, updating global sort options', { sortOptions: newConfig.sortOptions })\n            globalSortOptions = { ...globalSortOptions, ...newConfig.sortOptions }\n\n            // Clear cache when sort options change\n            lastSortedData = []\n            lastDataHash = ''\n            lastSortCacheKey = ''\n\n            // Trigger re-sort if there's an active sort config\n            if (currentSortConfig && debouncedDataProcessing) {\n              debouncedDataProcessing()\n            }\n          }\n        })\n\n        // Store unsubscribe function\n        eventUnsubscribe = () => {\n          unsubscribeColumns()\n          unsubscribeConfig()\n        }\n      }\n\n      // Initialize current columns from API\n      const currentState = api.getState()\n      if (currentState?.columns) {\n        currentColumns = currentState.columns\n      }\n\n      // Initialize global sort options from config\n      if (currentState?.config?.sortOptions) {\n        logger.debug('Initializing global sort options from config', { sortOptions: currentState.config.sortOptions })\n        globalSortOptions = { ...currentState.config.sortOptions }\n      }\n\n      const features = sortingInterceptor.metadata?.supportedFeatures?.join(', ') || 'single-field'\n      logger.info(`Sorting functionality installed with features: ${features}`)\n    },\n\n    cleanup(): void {\n      if (eventUnsubscribe) {\n        eventUnsubscribe()\n        eventUnsubscribe = null\n      }\n      currentSortConfig = null\n      globalSortOptions = {}\n      debouncedDataProcessing = null\n      sortingInterceptor = null\n      logger.info('Cleaned up')\n    },\n  }\n}\n\n// Convenience exports\nexport const sortingPlugin: GridPlugin = createSortingPlugin()\nexport const basicSortingPlugin: GridPlugin = createSortingPlugin({ enableMultiSort: false })\nexport const enhancedSortingPlugin: GridPlugin = createSortingPlugin({ enableMultiSort: true })\n\n// Note: SortingPluginOptions is already exported above\n"],"mappings":";AAeA,SAAgB,mBAAmB,GAAuC;AACxE,QAEE,OAAO,KAAW,cADlB,KAEA,WAAW,KACX,eAAe,KACf,OAAQ,EAAmC,SAAU,YACrD,CAAC,OAAO,OAAO,CAAC,SAAU,EAAmC,UAAoB;;AAIrF,SAAgB,kBAAkB,GAA4C;AAC5E,QAEE,OAAO,KAAW,cADlB,KAEA,YAAY,KACZ,MAAM,QAAS,EAAmC,OAAO;;AAO7D,SAAS,kBAAkB,GAAkC;CAC3D,IAAMA,IAA8B,EAAE,EAChC,IAAQ,gBACVC;AAEJ,SAAQ,IAAQ,EAAM,KAAK,EAAI,MAAM,MACnC,CAAI,EAAM,KAER,EAAO,KAAK,SAAS,EAAM,IAAI,GAAG,CAAC,GAC1B,EAAM,MAEf,EAAO,KAAK,EAAM,GAAG;AAIzB,QAAO;;AAWT,SAAS,eAAe,GAAW,GAAW,IAAgB,IAAe;CAC3E,IAAM,IAAU,kBAAkB,IAAgB,IAAI,EAAE,aAAa,CAAC,EAChE,IAAU,kBAAkB,IAAgB,IAAI,EAAE,aAAa,CAAC,EAEhE,IAAY,KAAK,IAAI,EAAQ,QAAQ,EAAQ,OAAO;AAE1D,MAAK,IAAI,IAAI,GAAG,IAAI,GAAW,KAAK;EAClC,IAAM,IAAS,EAAQ,IACjB,IAAS,EAAQ;AAGvB,MAAI,MAAW,KAAA,EAAW,QAAO;AACjC,MAAI,MAAW,KAAA,EAAW,QAAO;AAGjC,MAAI,OAAO,KAAW,YAAY,OAAO,KAAW,UAAU;AAC5D,OAAI,MAAW,EACb,QAAO,IAAS;AAElB;;AAIF,MAAI,OAAO,KAAW,YAAY,OAAO,KAAW,UAAU;GAC5D,IAAM,IAAa,EAAO,cAAc,EAAO;AAC/C,OAAI,MAAe,EACjB,QAAO;AAET;;AAIF,MAAI,OAAO,KAAW,SAAU,QAAO;AACvC,MAAI,OAAO,KAAW,SAAU,QAAO;;AAGzC,QAAO;;AAMT,IAAa,eAAb,MAA0B;CAIxB,OAAO,cAAc,GAAc,GAAc,GAA+B;AAE9E,MAAI,MAAM,QAAQ,MAAM,KAAM,QAAO;AACrC,MAAI,KAAM,KAAyB,QAAO;AAC1C,MAAI,KAAM,KAAyB,QAAO;AAG1C,MAAI,OAAO,KAAM,YAAY,OAAO,KAAM,SACxC,QAAO,IAAI;AAGb,MAAI,aAAa,QAAQ,aAAa,KACpC,QAAO,EAAE,SAAS,GAAG,EAAE,SAAS;EAIlC,IAAM,IAAO,OAAO,EAAE,EAChB,IAAO,OAAO,EAAE;AAGtB,MAAI,GAAS,YAEX,KAAI;AAKF,UAJiB,IAAI,KAAK,SAAS,EAAQ,QAAQ;IACjD,SAAS;IACT,aAAa,EAAQ,eAAe;IACrC,CAAC,CACc,QAAQ,GAAM,EAAK;UAC7B;GAEN,IAAM,IAAgB,EAAQ,gBAAgB,aAAa,EAAQ,gBAAgB;AACnF,UAAO,eAAe,GAAM,GAAM,EAAc;;AAWpD,SANI,GAAS,UAAU,GAAS,cACvB,EAAK,cAAc,GAAM,EAAQ,QAAQ,EAC9C,aAAa,EAAQ,aACtB,CAAC,GAGG,EAAK,cAAc,EAAK;;CAMjC,OAAO,eAAe,GAAiB,GAAsB,GAAwC;AACnG,MAAI,CAAC,EAAK,OAAQ,QAAO;EAEzB,IAAM,EAAE,UAAO,cAAW,eAAY,wBAAqB;AAE3D,SAAO,CAAC,GAAG,EAAK,CAAC,MAAM,GAAG,MAAM;GAC9B,IAAM,IAAO,EAAE,IACT,IAAO,EAAE;AAGf,OAAI,MAAe,KAAA,GAAW;AAC5B,QAAK,KAAS,QAAgC,KAAS,KAA6B,QAAO;AAC3F,QAAI,KAAS,KAA4B,QAAO,IAAa,KAAK;AAClE,QAAI,KAAS,KAA4B,QAAO,IAAa,IAAI;;GAInE,IAAIC;AACJ,OAAI;AACF,QAAa,IACT,EAAiB,GAAM,EAAK,GAC5B,KAAK,cAAc,GAAM,GAAM,EAAc;WAClC;AAEf,QAAa,KAAK,cAAc,GAAM,GAAM,EAAc;;AAG5D,UAAO,MAAc,SAAS,CAAC,IAAa;IAC5C;;CAOJ,OAAO,eAAe,GAAiB,GAAyB,GAAwC;AACtG,MAAI,CAAC,EAAK,UAAU,EAAW,WAAW,EAAG,QAAO;EAGpD,IAAM,IAAc,KAAK,mBAAmB,EAAW;AACvD,MAAI,EAAY,WAAW,EAAG,QAAO;EAGrC,IAAM,IAAe,CAAC,GAAG,EAAY,CAAC,MAAM,GAAG,MAAM,EAAE,WAAW,EAAE,SAAS;AAE7E,SAAO,CAAC,GAAG,EAAK,CAAC,MAAM,GAAG,MAAM;AAC9B,QAAK,IAAM,KAAa,GAAc;IACpC,IAAM,EAAE,UAAO,cAAW,eAAY,wBAAqB,GACrD,IAAO,EAAE,IACT,IAAO,EAAE,IAKTC,IAA6B;KACjC,GAAG;KAEH,GAAI,EAAU,gBAAgB,KAAA,KAAa,EAAE,aAAa,EAAU,aAAa;KACjF,GAAI,EAAU,gBAAgB,KAAA,KAAa,EAAE,aAAa,EAAU,aAAa;KACjF,GAAI,EAAU,WAAW,KAAA,KAAa,EAAE,QAAQ,EAAU,QAAQ;KACnE;AAGD,QAAI,MAAe,KAAA,GAAW;AAC5B,SAAK,KAAS,QAAgC,KAAS,KAA6B;AACpF,SAAI,KAAS,KAA4B,QAAO,IAAa,KAAK;AAClE,SAAI,KAAS,KAA4B,QAAO,IAAa,IAAI;;IAInE,IAAID;AACJ,QAAI;AACF,SAAa,IACT,EAAiB,GAAM,EAAK,GAC5B,KAAK,cAAc,GAAM,GAAM,EAAc;YAClC;AAEf,SAAa,KAAK,cAAc,GAAM,GAAM,EAAc;;AAG5D,QAAI,MAAe,EACjB,QAAO,MAAc,SAAS,CAAC,IAAa;;AAIhD,UAAO;IACP;;CAMJ,OAAO,qBAAqB,GAAqE;AAsB/F,SArBK,IAED,mBAAmB,EAAO,GACrB,EACL,QAAQ,CACN;GACE,OAAO,EAAO;GACd,WAAW,EAAO;GAClB,UAAU;GACX,CACF,EACF,GAGC,kBAAkB,EAAO,GACpB;GACL,GAAG;GACH,QAAQ,KAAK,mBAAmB,EAAO,OAAO;GAC/C,GAGI,OArBa;;CA2BtB,OAAO,mBAAmB,GAAkC;AAG1D,SAFK,MAAM,QAAQ,EAAO,GAEnB,EACJ,QAAO,MACN,KACA,OAAO,KAAU,YACjB,OAAO,EAAM,SAAU,YACvB,EAAM,MAAM,MAAM,KAAK,MACvB,CAAC,OAAO,OAAO,CAAC,SAAS,EAAM,UAAU,CAC1C,CACA,KAAK,GAAO,OAAW;GACtB,GAAG;GACH,UAAU,OAAO,EAAM,YAAa,WAAW,EAAM,WAAW;GACjE,EAAE,CACF,MAAM,GAAG,MAAM,EAAE,WAAW,EAAE,SAAS,GAdP,EAAE;;CAoBvC,OAAO,wBAAwB,GAAkC;AAE/D,SADoB,KAAK,mBAAmB,EAAO,CAChC,KAAK,GAAO,OAAW;GAAE,GAAG;GAAO,UAAU;GAAO,EAAE;;CAM3E,OAAO,oBACL,GACA,GACS;AACT,MAAI,MAAY,EAAS,QAAO;AAChC,MAAI,CAAC,KAAW,CAAC,EAAS,QAAO;EAEjC,IAAM,IAAc,KAAK,qBAAqB,EAAQ,EAChD,IAAc,KAAK,qBAAqB,EAAQ;AAKtD,SAHI,CAAC,KAAe,CAAC,KACjB,EAAY,OAAO,WAAW,EAAY,OAAO,SAAe,KAE7D,EAAY,OAAO,OAAO,GAAQ,MAAU;GACjD,IAAM,IAAS,EAAY,OAAO;AAClC,UAAO,KACL,EAAO,UAAU,EAAO,SACxB,EAAO,cAAc,EAAO,aAC5B,EAAO,aAAa,EAAO,YAC3B,EAAO,eAAe,EAAO;IAC/B;;GCzTO,oBAAb,MAA+B;CAC7B;CAEA,YAAY,GAAc;AACxB,OAAK,MAAM;;CAMb,KAAiC,GAAU,GAA8B;AACvE,EAAI,KAAK,IAAI,QACX,KAAK,IAAI,KAAK,GAAO,EAAQ;;CAOjC,GACE,GACA,GAC0B;AAC1B,MAAI,KAAK,IAAI,GACX,QAAO,KAAK,IAAI,GAAG,GAAO,EAAQ;;CAQtC,IACE,GACA,GACM;AACN,EAAI,KAAK,IAAI,OACX,KAAK,IAAI,IAAI,GAAO,EAAQ;;GAQrB,mBAAb,MAA8B;CAC5B;CAEA,YAAY,GAAc;AACxB,OAAK,UAAU,IAAI,kBAAkB,EAAI;;CAI3C,oBAAoB,GAA+C;AACjE,OAAK,QAAQ,KAAK,qBAAqB,EAAO;;CAGhD,mBAAmB,GAA4C;AAC7D,OAAK,QAAQ,KAAK,oBAAoB,EAAK;;CAG7C,qBAAqB,GAA8C;AACjE,OAAK,QAAQ,KAAK,sBAAsB,EAAK;;CAG/C,wBAAwB,GAAiD;AACvE,OAAK,QAAQ,KAAK,yBAAyB,EAAK;;CAIlD,wBAAwB,GAAiD;AACvE,OAAK,QAAQ,KAAK,yBAAyB,EAAK;;CAGlD,gBAAgB,GAAwC;AACtD,OAAK,QAAQ,KAAK,gBAAgB,EAAK;;CAGzC,cAAc,GAAsC;AAClD,OAAK,QAAQ,KAAK,cAAc,EAAK;;CAGvC,mBAAmB,GAA2C;AAC5D,OAAK,QAAQ,KAAK,mBAAmB,EAAK;;CAI5C,kBAAkB,GAA0C;AAC1D,OAAK,QAAQ,KAAK,kBAAkB,EAAK;;CAG3C,yBAAyB,GAAkD;AACzE,OAAK,QAAQ,KAAK,0BAA0B,EAAK;;CAGnD,sBAAsB,GAAgD;AACpE,OAAK,QAAQ,KAAK,uBAAuB,EAAM;;CAIjD,oBAAoB,GAA6C;AAC/D,OAAK,QAAQ,KAAK,qBAAqB,EAAK;;CAG9C,kBAAkB,GAA2C;AAC3D,OAAK,QAAQ,KAAK,mBAAmB,EAAK;;CAG5C,qBAAqB,GAA8C;AACjE,OAAK,QAAQ,KAAK,sBAAsB,EAAK;;CAG/C,mBAAmB,GAA4C;AAC7D,OAAK,QAAQ,KAAK,oBAAoB,EAAK;;CAI7C,iBAAiB,GAAyC;AACxD,OAAK,QAAQ,KAAK,iBAAiB,EAAK;;CAG1C,mBAAmB,GAA2C;AAC5D,OAAK,QAAQ,KAAK,mBAAmB,EAAK;;CAG5C,gBAAgB,GAAwC;AACtD,OAAK,QAAQ,KAAK,gBAAgB,EAAK;;CAIzC,KAAiC,GAAU,GAA8B;AACvE,OAAK,QAAQ,KAAK,GAAO,EAAQ;;CAInC,GACE,GACA,GAC0B;AAC1B,SAAO,KAAK,QAAQ,GAAG,GAAO,EAAQ;;CAIxC,IACE,GACA,GACM;AACN,OAAK,QAAQ,IAAI,GAAO,EAAQ;;;AAOpC,SAAgB,sBAAsB,GAAgC;AACpE,QAAO,IAAI,iBAAiB,EAAI;;AAMlC,SAAgB,qBAAqB,GAA+E;AAClH,QAAO,OAAO,EAAI,QAAS;;ACnJ7B,SAAS,qBAAqB,GAA4E;AAexG,QAdI,CAAC,KAAa,CAAC,EAAU,WACpB,OAIL,EAAU,aAAa,KAClB,EAAE,GAIP,OAAO,EAAU,YAAa,WACzB,EAAU,WAGZ;;AAOT,SAAS,iBAAiB,GAA4B,GAAgD;AAKpG,QAJK,IAIE;EACL,GAAG;EACH,GAAG;EACJ,GANQ;;AAYX,SAAgB,oBAAoB,IAAgC,EAAE,EAAc;CAElF,IAAM,IAAS,aAAa;EAAE,QAAQ;EAAU,WAAW;EAAiB,CAAC,EAGvE,IAAS;EACb,iBAAiB,EAAQ,mBAAmB;EAC5C,eAAe,KAAK,IAAI,GAAG,KAAK,IAAI,EAAQ,iBAAiB,GAAG,GAAG,CAAC;EACrE;AAED,GAAO,MAAM,2BAA2B;EAAE;EAAQ;EAAS,CAAC;CAG5D,IAAIE,IAA4C,MAC5CC,IAAiC,EAAE,EACnCC,IAA6C,MAC7CC,IAA+C,MAC/CC,IAAoB,MACpBC,IAAwC,MACxCC,IAAoD,EAAE,EAGtDC,IAA8D,MAG9DC,IAA4B,EAAE,EAC9BC,IAA2B,IAC3BC,IAAuB,IAGrB,KAA2D,GAAS,MAAoB;EAC5F,IAAIC,IAAyB;AAC7B,WAAS,GAAG,MAAwB;AAElC,GADI,KAAS,aAAa,EAAQ,EAClC,IAAU,iBAAiB,EAAK,GAAG,EAAK,EAAE,EAAK;;IAK7C,KAAsC,GAAc,MACjD,OAAO,EAAI,MAAY,YAI1B,KAAiB,GAAc,MAA0D;EAC7F,IAAM,IAAmB,aAAa,qBAAqB,EAAW;AAgBtE,MAdA,EAAO,MAAM,wBAAwB;GACnC,gBAAgB;GAChB;GACA;GACA,iBAAiB,EAAO;GACzB,CAAC,EAGE,CAAC,EAAO,mBAAmB,GAAkB,UAAU,EAAiB,OAAO,SAAS,MAC1F,EAAO,KAAK,mDAAmD,EAC/D,EAAiB,SAAS,EAAiB,OAAO,MAAM,GAAG,EAAE,GAI3D,CAAC,aAAa,oBAAoB,GAAmB,EAAiB,EAAE;AAU1E,GATA,EAAO,KAAK,qEAAqE,EACjF,IAAoB,GAGpB,IAAiB,EAAE,EACnB,IAAmB,IACnB,IAAe,IAGX,MACF,EAAmB,UAAU,MAAqB;AAIpD,OAAI;AAIF,IAHI,EAAU,GAAK,eAAe,IAChC,EAAI,aAAa,EAAE,MAAM,GAAY,CAAC,EAEpC,KAAc,qBAAqB,EAAI,IAErC,MACF,EAAW,oBAAoB,EAAiB,EAChD,EAAO,MAAM,mCAAmC,EAAE,QAAQ,GAAkB,CAAC;YAG1E,GAAO;AACd,MAAO,KAAK,+BAA+B,EAAM;;AAInD,GAAI,KACF,GAAyB;;IAKzB,UAEA,KACG,MAGH,KAAgB,GAAc,GAAe,MAAqC;AACtF,MAAI,CAAC,KAAS,OAAO,KAAU,UAAU;AACvC,KAAO,KAAK,yCAAyC;AACrD;;AAGF,MAAI,CAAC,GAAW;GACd,IAAM,IAAgB,GAAmB,OAAO,MAAK,MAAK,EAAE,UAAU,EAAM;AAG5E,OAAI,CAAC,EACH,KAAY;YACH,EAAc,cAAc,MACrC,KAAY;QACP;AAKL,IAHA,EAAO,MAAM,2BAA2B,EAAE,UAAO,CAAC,EAG9C,KAAqB,EAAkB,OAAO,WAAW,IAC3D,EAAc,GAAK,KAAK,GAGxB,EAAgB,GAAK,EAAM;AAE7B;;;AAQJ,IAAc,GAJqB,EACjC,QAAQ,CAAC;GAAE;GAAO;GAAW,UAAU;GAAG,CAAC,EAC5C,CAE4B;IAGzB,KAAgB,GAAc,GAAe,MAAqC;AACtF,MAAI,CAAC,KAAS,OAAO,KAAU,UAAU;AACvC,KAAO,KAAK,yCAAyC;AACrD;;EAIF,IAAM,IAAgB,CAAC,GAAI,GAAmB,UAAU,EAAE,CAAE,EACtD,IAAY,EAAO;AAEzB,IAAO,MAAM,uBAAuB;GAAE;GAAO;GAAW;GAAe;GAAW,CAAC;EAGnF,IAAM,IAAgB,EAAc,WAAU,MAAK,EAAE,UAAU,EAAM;AACrE,MAAI,MAAkB,IAAI;GACxB,IAAM,IAAmB,EAAc,GAAgB;AAEvD,OAAK,EAiCH,CADA,EAAc,KAAiB;IAAE,GAAG,EAAc;IAAiB;IAAW,EAC9E,EAAO,MAAM,kDAAkD;IAAE,OAAO;IAAe;IAAW,CAAC;YA/B/F,MAAqB,MAGvB,CADA,EAAc,KAAiB;IAAE,GAAG,EAAc;IAAiB,WAAW;IAAQ,EACtF,EAAO,MAAM,kCAAkC;IAAE,OAAO;IAAe,MAAM;IAAkB,CAAC;QAC3F;AAML,QAJA,EAAc,OAAO,GAAe,EAAE,EACtC,EAAO,MAAM,iCAAiC;KAAE;KAAO,iBAAiB,EAAc;KAAQ,CAAC,EAG3F,EAAc,WAAW,GAAG;AAE9B,KADA,EAAc,GAAK,KAAK,EACpB,KACF,EAAW,qBAAqB;MAAE;MAAO,YAAY,EAAE,QAAQ,EAAE,EAAE;MAAE,CAAC;AAExE;;IAIF,IAAMC,IAA6B,EACjC,QAAQ,aAAa,wBAAwB,EAAc,EAC5D;AAED,IADA,EAAc,GAAK,EAAU,EACzB,KACF,EAAW,qBAAqB;KAAE;KAAO,YAAY;KAAW,CAAC;AAEnE;;aAOK,EAAc,SAAS,GAAW;GAE3C,IAAM,IAAe,KAAa;AAElC,GADA,EAAc,KAAK;IAAE;IAAO,WAAW;IAAc,UAAU,EAAc;IAAQ,CAAC,EACtF,EAAO,MAAM,mBAAmB;IAAE,aAAa,EAAc;IAAQ,WAAW;IAAc,CAAC;SAC1F;AACL,KAAO,KAAK,wBAAwB,EAAU,WAAW;AACzD;;EAGF,IAAMA,IAA6B,EACjC,QAAQ,aAAa,wBAAwB,EAAc,EAC5D;AAMD,EAJA,EAAO,MAAM,6CAA6C,EAAE,cAAW,CAAC,EACxE,EAAc,GAAK,EAAU,EAGzB,KACF,EAAW,mBAAmB;GAAE,OAAO;IAAE;IAAO,WAAW,KAAa;IAAO,UAAU;IAAG;GAAE,YAAY;GAAW,CAAC;IAIpH,KAAmB,GAAc,MAAwB;AAC7D,MAAI,CAAC,KAAqB,CAAC,EAAO;EAElC,IAAM,IAAiB,EAAkB,OAAO,QAAO,MAAK,EAAE,UAAU,EAAM;AAE9E,MAAI,EAAe,WAAW,EAC5B,GAAc,GAAK,KAAK;OACnB;GACL,IAAMA,IAA6B,EACjC,QAAQ,aAAa,wBAAwB,EAAe,EAC7D;AAGD,GAFA,EAAc,GAAK,EAAU,EAEzB,KACF,EAAW,qBAAqB;IAAE;IAAO,YAAY;IAAW,CAAC;;IAKjE,KAAsB,GAAc,GAAe,MAA8B;AACrF,MAAI,CAAC,KAAqB,CAAC,KAAS,OAAO,KAAgB,SAAU;EAErE,IAAM,IAAS,CAAC,GAAG,EAAkB,OAAO,EACtC,IAAa,EAAO,WAAU,MAAK,EAAE,UAAU,EAAM;AAE3D,MAAI,MAAe,GAAI;EAGvB,IAAM,IAAc,EAAO,SAAS,GAC9B,IAAkB,KAAK,IAAI,GAAG,KAAK,IAAI,GAAa,EAAY,CAAC;AAGvE,IAAO,KAAc;GAAE,GAAG,EAAO;GAAc,UAAU;GAAiB;EAE1E,IAAMA,IAA6B,EACjC,QAAQ,aAAa,wBAAwB,EAAO,EACrD;AAGD,EAFA,EAAc,GAAK,EAAU,EAEzB,KACF,EAAW,wBAAwB;GACjC;GACA,aAAa,EAAkB,OAAO,IAAa,YAAY;GAC/D,aAAa;GACd,CAAC;;AAMN,QAAO;EACL,MAAM;EACN,SAAS;EACT,cAAc,CAAC,gBAAgB;EAE/B,QAAQ,GAAc,GAA6B;AAGjD,OAFA,IAAe,EAAI,gBAAgB,EAE/B,CAAC,GAAc;AACjB,MAAO,KAAK,yCAAyC;AACrD;;AAkHF,GA9GA,IAAa,sBAAsB,EAAI,EAGvC,IAA0B,QAAsB;AAE9C,IAAI,KACF,EAAW,KAAK,0BAA0B,EAAE,QAAQ,WAAW,CAAC;MAEjE,GAAG,EAGN,IAAqB;IACnB,MAAM;IACN,MAAM;IACN,UAAU;IACV,SAAS;IACT,YAAY,MAAoB;KAE9B,IAAM,IAAW,KAAK,UAAU,EAAK,SAAS,IAAI,CAAC,EAAK,IAAI,EAAK,OAAO,GAAG,EAAE,CAAC,EACxE,IAAiB,KAAK,UAAU,EAAkB;AAQxD,SANA,EAAO,MAAM,wCAAwC;MACnD,YAAY,EAAK;MACjB;MACA,aAAa,GAAmB,QAAQ,UAAU;MACnD,CAAC,EAEE,CAAC,KAAqB,CAAC,EAAK,UAAU,EAAkB,OAAO,WAAW,EAE5E,QADA,EAAO,MAAM,2DAA2D,EACjE;AAGT,SAAI;MAGF,IAAM,IAA0B,EAAkB,OAAO,KAAI,MAAS;OACpE,IAAM,IAAS,EAAe,MAAK,MAAO,EAAI,UAAU,EAAM,MAAM,EAC9D,IAAoB,qBAAqB,EAAO,EAChD,IAAwB,iBAAiB,GAAmB,EAAkB;AAIpF,cAAO;QACL,OAAO,EAAM;QACb,WAAW,EAAM;QACjB,UAAU,EAAM;QAChB,GAAG;QAEH,GAAI,EAAM,gBAAgB,KAAA,KAAa,EAAE,aAAa,EAAM,aAAa;QACzE,GAAI,EAAM,gBAAgB,KAAA,KAAa,EAAE,aAAa,EAAM,aAAa;QACzE,GAAI,EAAM,WAAW,KAAA,KAAa,EAAE,QAAQ,EAAM,QAAQ;QAC1D,GAAI,EAAM,eAAe,KAAA,KAAa,EAAE,YAAY,EAAM,YAAY;QACtE,GAAI,EAAM,qBAAqB,KAAA,KAAa,EAAE,kBAAkB,EAAM,kBAAkB;QACzF;QACD,EAGI,IAAc,KAAK,UACvB,EAAwB,KAAI,OAAM;OAChC,OAAO,EAAE;OACT,WAAW,EAAE;OACb,UAAU,EAAE;OACZ,aAAc,EAAkB,eAAe;OAC/C,aAAc,EAAkB,eAAe,KAAA;OAC/C,QAAS,EAAkB,UAAU,KAAA;OACrC,YAAa,EAAkB,cAAc,KAAA;OAC9C,EAAE,CACJ,EAGK,IAAe,GAAG,EAAe,GAAG;AAG1C,UACE,MAAa,KACb,MAAiB,KACjB,EAAe,SAAS,EAGxB,QADA,EAAO,MAAM,iEAAiE,EACvE;MAKT,IAAM,IAAa,aAAa,eAAe,GAAM,GAAyB,EAAkB;AAYhG,aATA,IAAiB,GACjB,IAAe,GACf,IAAmB,GAEnB,EAAO,MAAM,4BAA4B;OACvC,gBAAgB,EAAK;OACrB,cAAc,EAAW;OACzB,YAAY;OACb,CAAC,EACK;cACA,GAAO;AAEd,aADA,EAAO,MAAM,yBAAyB,EAAM,EACrC;;;IAGX,UAAU;KACR,aAAa,EAAO,kBAAkB,wBAAwB;KAC9D,SAAS;KACT,mBAAmB,CAAC,gBAAgB,GAAI,EAAO,kBAAkB,CAAC,cAAc,GAAG,EAAE,CAAE;KACxF;IACF,EAGD,EAAa,wBAAwB,QAAQ,EAAmB;GAGhE,IAAM,IAAc;AAgEpB,OA7DA,EAAY,iBAAiB,MAAoD,EAAc,GAAK,EAAW,EAC/G,EAAY,sBAAsB,GAAe,EACjD,EAAY,gBAAgB,GAAe,MAA+B,EAAa,GAAK,GAAO,EAAU,EAC7G,EAAY,kBAAkB,EAAc,GAAK,KAAK,EAGlD,EAAO,mBACT,EAAO,MAAM,iCAAiC,EAAE,WAAQ,CAAC,EACzD,EAAY,2BAA2B,GACvC,EAAY,gBAAgB,GAAe,OACzC,EAAO,MAAM,2BAA2B;IAAE;IAAO;IAAW,CAAC,EACtD,EAAa,GAAK,GAAO,EAAU,GAE5C,EAAY,mBAAmB,MAAkB,EAAgB,GAAK,EAAM,EAC5E,EAAY,sBAAsB,GAAe,MAAwB,EAAmB,GAAK,GAAO,EAAY,IAEpH,EAAO,MAAM,uBAAuB,EAAE,WAAQ,CAAC,EAIjD,EAAY,kBAAkB,MAAyB;AACrD,IAAI,KAAW,OAAO,KAAY,aAChC,IAAoB;KAAE,GAAG;KAAmB,GAAG;KAAS,EACpD,KAAqB,KACvB,GAAyB;MAI/B,EAAY,uBAAuB,GAGnC,EAAY,yBAAyB;IACnC,YAAY;IACZ,eAAe;IACf,SAAS;IACV,GAED,EAAY,mBAAmB,MAAmC;AAIhE,IAHI,GAAO,cACT,EAAc,GAAK,EAAM,WAA2C,EAElE,GAAO,kBACT,IAAoB,EAAM;MAK9B,EAAY,8BAA8B;AAUxC,IATI,KAAgB,KAClB,EAAa,sBAAsB,QAAQ,UAAU,EAEnD,KACF,GAAkB,EAEpB,IAAoB,MACpB,IAAoB,EAAE,EACtB,IAA0B,MAC1B,IAAqB;MAInB,KAAc,EAAI,IAAI;IAExB,IAAM,IAAqB,EAAI,GAAG,oBAAoB,MAA+C;AAUnG,KATA,IAAiB,GACjB,EAAO,MAAM,mBAAmB,EAAE,aAAa,EAAQ,QAAQ,CAAC,EAGhE,IAAiB,EAAE,EACnB,IAAe,IACf,IAAmB,IAGf,KAAqB,KACvB,GAAyB;MAE3B,EAGI,IAAoB,EAAI,GAAG,mBAAmB,MAAgD;AAClG,KAAI,EAAU,gBACZ,EAAO,MAAM,gDAAgD,EAAE,aAAa,EAAU,aAAa,CAAC,EACpG,IAAoB;MAAE,GAAG;MAAmB,GAAG,EAAU;MAAa,EAGtE,IAAiB,EAAE,EACnB,IAAe,IACf,IAAmB,IAGf,KAAqB,KACvB,GAAyB;MAG7B;AAGF,cAAyB;AAEvB,KADA,GAAoB,EACpB,GAAmB;;;GAKvB,IAAM,IAAe,EAAI,UAAU;AAMnC,GALI,GAAc,YAChB,IAAiB,EAAa,UAI5B,GAAc,QAAQ,gBACxB,EAAO,MAAM,gDAAgD,EAAE,aAAa,EAAa,OAAO,aAAa,CAAC,EAC9G,IAAoB,EAAE,GAAG,EAAa,OAAO,aAAa;GAG5D,IAAM,IAAW,EAAmB,UAAU,mBAAmB,KAAK,KAAK,IAAI;AAC/E,KAAO,KAAK,kDAAkD,IAAW;;EAG3E,UAAgB;AASd,GARA,AAEE,OADA,GAAkB,EACC,OAErB,IAAoB,MACpB,IAAoB,EAAE,EACtB,IAA0B,MAC1B,IAAqB,MACrB,EAAO,KAAK,aAAa;;EAE5B;;AAIH,MAAaC,gBAA4B,qBAAqB;AAChB,oBAAoB,EAAE,iBAAiB,IAAO,CAAC;AAC7F,MAAaE,wBAAoC,oBAAoB,EAAE,iBAAiB,IAAM,CAAC"}